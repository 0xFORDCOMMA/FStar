import sys
import os, os.path
import re
import collections
import SCons


Import('My_env')
env = My_env.Clone()  # ensure changes here don't have impact on other SConscripts
ocaml_output = 'ocaml-output/'  # directory to extract Ocaml code to

# --------------------------------------------------------------------
# Generate boot files
# --------------------------------------------------------------------

# Return a list, where each element is the concatenation of prefix 'p' with the original element
def addprefix(p, l):
  if isinstance(l, basestring):
    # l is a space-separated string.  Split into a list of strings.
    l = l.split(' ')
  # else l is a list to begin with
  return [p+x for x in l]

# Scons action, which takes a text source file, and emits a text target file,
# having used the generator function to transform source to target.
def generate_boot_file(target, source, env, generator):
    # read the source file into memory
    try:
        fd = open(source[0].get_path(), 'r')
    except (OSError,IOError), e:
        raise SCons.Errors.UserError("Can't read source file %s" % source[0])
    sourcefile = fd.read()
    sourcelines = re.split('\r|\n', sourcefile)
    fd.close()

    # munge the source file into the target file
    targetlines = generator(sourcelines)

    # write the target file
    try:
        fd = open(target[0].get_path(), "w")
    except (OSError,IOError), e:
        raise SCons.Errors.UserError("Can't write target file %s" % target[0])
    for l in targetlines:
        fd.write(l)
        fd.write('\n')
    fd.close()

# Scons action, which takes a text source file, and emits a text target file,
# having used the generator function to transform each line of source to target.
def generate_boot_file_ex(target, source, env, generator):
  def LineByLineGenerator(sourcelines):
    targetlines = []
    for s in sourcelines:
      t = generator(s)
      if t != None:
        targetlines.append(t)
    return targetlines
  generate_boot_file(target, source, env, LineByLineGenerator)

# Generate boot/FStar.Tactics.Interpreter.fst from tactics/boot/FStar.Tactics.Interpreter.fs
def generate_TacticsInterpreter(target, source, env):
  def process(s):
    if re.search(r'// *JUST *FSHARP *', s):
      return None
    t = re.sub(r'// *IN F\* *:', '', s)
    return t
  return generate_boot_file_ex(target, source, env, process)

# Generate 'boot/FStar.Parser.Parse.fsti from parser/boot/parser.fsi
def generate_ParserParse(target, source, env):
  def process(sourcelines):
    match = 'module FStar.Parser.Parse'
    replace = 'module FStar.Parser.Parse\nopen FStar.All\nopen FStar.BaseTypes\ntype bytes = array<byte>'
    targetlines = ['#light "off"']
    for i in range(0,len(sourcelines)-13):
      targetlines.append(sourcelines[i].replace(match, replace))
    return targetlines
  return generate_boot_file(target, source, env, process)

# Generate a file by simply copying it
def generate_Copy(target, source, env):
  def process(s):
    return s
  return generate_boot_file_ex(target, source, env, process)

# Generate boot/%.fsti from basic/boot/%.fsi
def generate_Basic(target, source, env):
  def process(s):
    if re.search(r'// *JUST *FSHARP *', s):
      return None
    t = re.sub(r'<.* when .* : equality>', '', s)
    return t
  return generate_boot_file_ex(target, source, env, process)

# Generate boot/%.fsti from prettyprint/boot/%.fsi
def generate_PrettyPrint(target, source, env):
  def process(s):
    if re.search(r'// *JUST *FSHARP *', s):
      return None
    return s
  return generate_boot_file_ex(target, source, env, process)

# all boot files are listed here
ALL_BOOT=addprefix('boot/FStar.',
  ['Util.fsti','List.fsti','Bytes.fsti','String.fsti',
   'Range.fsti','Pprint.fsti','Parser.Parse.fsti',
   'Tactics.Interpreter.fst','Tactics.Interpreter.fsti'])

# Instructions on how to generate all of the ALL_BOOT files
              # tuples of:  (target filename, source filename, and how to generate)
Boot_Rules = [('boot/FStar.Tactics.Interpreter.fst', 'tactics/boot/FStar.Tactics.Interpreter.fs', generate_TacticsInterpreter),
              ('boot/FStar.Parser.Parse.fsti', 'parser/boot/parse.fsi', generate_ParserParse),
              ('boot/FStar.Parser.Parse.fst', 'parser/boot/parser.fs', generate_Copy),
              ('boot/FStar.Tactics.Interpreter.fsti', 'tactics/boot/FStar.Tactics.Interpreter.fsi', generate_Copy),
              ('boot/%.fsti', 'basic/boot/%.fsi', generate_Basic),
              ('boot/%.fsti', 'prettyprint/boot/%.fsi', generate_PrettyPrint),
              ('boot/%.fst', 'basic/boot/%.fs', generate_Copy)
              ]

# Split a pathname into a tuple of (path, basename, extension)
def split_path(p):
  p, n = os.path.split(p)
  root, ext = os.path.splitext(n)
  Parts = collections.namedtuple('Parts', 'path basename extension')
  return Parts(p, root, ext)

# Generate build targets for all files in ALL_BOOT, using the Boot_Rules
boot_target = env.Alias('boot')
for t in ALL_BOOT:
  tparts = split_path(t)
  x = None
  for target, source, action in Boot_Rules:
    if target == t:
        x = env.Command(target, source,  action)
        break
    elif '%' in target:
      # split t into path, basename, and extension
      sourceparts = split_path(source)
      computedsource = sourceparts.path + '/' + tparts.basename + sourceparts.extension
      if os.path.exists(computedsource):
        targetparts = split_path(target)
        computedtarget = targetparts.path + '/' + tparts.basename + targetparts.extension
        x = env.Command(computedtarget, computedsource, action)
        break
  if x == None:
    raise SCons.Errors.UserError('Boot file %s didn\'t match any rule in Boot_Rules'%t)
  env.Alias(boot_target, x)

# --------------------------------------------------------------------
# Extract boot files to .ml
# --------------------------------------------------------------------
if sys.platform == 'win32' or sys.platform == 'cygwin':  # Windows
    fstar_path = '../bin/fstar.exe'
else:  # Unix
    fstar_path = os.path.realpath('../bin/fstar.exe')
    if os.path.exists(fstar):
        filetype = subprocess.check_output(['file',fstar_path])
        if filetype.contains('Mono'):
            env['FSTAR'] = 'mono ' + env['FSTAR']  # F# version, mono fstar.exe
        else:
            env['FSTAR'] = fstar_path                           # OCaml verion, fstar.exe

boot_includes=addprefix('--include ', '../ulib boot basic extraction format fsdoc fstar '+\
                                      'parser prettyprint reflection smtencoding syntax '+\
                                      'tactics tosyntax typechecker')

# This is the way in which we invoke F* for boostrapping
#   -- we use automatic dependence analysis based on files in ulib, src/{basic, ...} and boot
#   -- eager_inference, MLish, lax: all tune type-inference for use with unverified ML programs
env['FSTARBOOT'] = '$FSTAR $OTHERFLAGS --eager_inference --lax --MLish --no_location_info ' + \
  '--odir ocaml-output --codegen OCaml ' + ' '.join(boot_includes)

# Common base for ExtractModule and ExtractNamespace
class ExtractionBase:
  def __init__(self, command, sources, targets):
    self.command = command;             # string
    self.sources = Flatten(sources);    # flattened list of source .fs filenames
    self.targets = Flatten(targets);    # flattened list of target .fst filenames

# Helper class for extracting a set of modules
class ExtractModule(ExtractionBase):
  def __init__(self, sources, modules):
    if type(sources)==type(''):
      sources = sources.split(' ')
    if type(modules)==type(''):
      modules = modules.split(' ')
    sources = Flatten(sources)
    m = Flatten(modules)
    self.command = ['--extract_module '+module for module in m]
    self.sources = sources
    self.targets = [ocaml_output+module.replace('.','_') + '.ml' for module in m]

# Generate the .ml target filename given an F* source filename
def GetTargetNameFromSourceFile(sourcefile):
  path,filename = os.path.split(sourcefile)
  base,ext = os.path.splitext(filename)
  return base.replace('.','_') + '.ml'

# Helper class for extracting a set of namespaces
class ExtractNamespace(ExtractionBase):
  def __init__(self, sources, namespaces, noextractions=[]):
    if type(sources)==type(''):
      sources = sources.split(' ')
    if type(namespaces)==type(''):
      namespaces = namespaces.split(' ')
    if type(noextractions)==type(''):
      noextractions = noextractions.split(' ')
    sources = Flatten(sources)
    namespaces = Flatten(namespaces)
    self.command = ['--extract_namespace ' + namespace for namespace in namespaces] + \
                   [' --no_extract ' + noextract for noextract in noextractions]
    self.sources = sources
    # filter out noextract files from the sources list, to build the targets list
    targets = []
    for t in sources:
      skip = False
      for n in Flatten(noextractions):
        if n in t:
          skip = True
          break
      if not skip:
        targets.append(t)
    self.targets = [ocaml_output+GetTargetNameFromSourceFile(file) for file in targets]

# The list of all things to extract from the boot files
# Tuples are:  (targetname, ExtractModule|ExtractNamespace)
Extractions=[
  ('extract_misc',ExtractModule(
   [addprefix('basic/','FStar.Common.fs FStar.Options.fs FStar.Ident.fs FStar.Errors.fs FStar.Const.fs FStar.Order.fs'),'format/FStar.Format.fs'],
   'FStar.Pervasives FStar.Common FStar.Options FStar.Ident FStar.Errors FStar.Const FStar.Format FStar.Order')
   ),
  ('extract_syntax',ExtractNamespace(
    [addprefix('syntax/FStar.Syntax.','Syntax.fs Subst.fs Free.fs InstFV.fs Util.fs Print.fs Embeddings.fs MutRecTy.fs Resugar.fs Unionfind.fs'),'fsdoc/FStar.Fsdoc.Generator.fs'],
   'FStar.Syntax FStar.Fsdoc')
   ),
  ('extract_parser',ExtractNamespace(
   addprefix('parser/FStar.Parser.','AST.fs ParseIt.fsi Driver.fs Dep.fs ToDocument.fs'),
   'FStar.Parser',
   'FStar.Parser.ParseIt')
   ),
  ('extract_normalizer',ExtractNamespace(
   addprefix('typechecker/FStar.TypeChecker.','Common.fs Env.fs Normalize.fs Err.fs'),
   'FStar.TypeChecker')
   ),
  ('extract_rel',ExtractModule(
   'typechecker/FStar.TypeChecker.Rel.fs',
   'FStar.TypeChecker.Rel')
   ),
  ('extract_util',ExtractModule(
   'typechecker/FStar.TypeChecker.Util.fs',
   'FStar.TypeChecker.Util')
   ),
  ('extract_dmff',ExtractModule(
   'typechecker/FStar.TypeChecker.DMFF.fs',
   'FStar.TypeChecker.DMFF')
   ),
  ('extract_tcterm',ExtractModule(
   'typechecker/FStar.TypeChecker.TcTerm.fs',
   'FStar.TypeChecker.TcTerm')
   ),
  ('extract_tcinductive',ExtractModule(
   'typechecker/FStar.TypeChecker.TcInductive.fs',
   'FStar.TypeChecker.TcInductive')
   ),
  ('extract_tc',ExtractModule(
   'typechecker/FStar.TypeChecker.Tc.fs',
   'FStar.TypeChecker.Tc')
   ),
  ('extract_tosyntax',ExtractNamespace(
   addprefix('tosyntax/FStar.ToSyntax.','Env.fs Interleave.fs ToSyntax.fs'),
   'FStar.ToSyntax')
   ),
  ('extract_extraction',ExtractNamespace(
   addprefix('extraction/FStar.Extraction.','ML.Syntax.fs ML.UEnv.fs ML.Util.fs ML.Code.fs ML.Term.fs ML.Modul.fs Kremlin.fs'),
   'FStar.Extraction')
   ),
  ('extract_tactics',ExtractNamespace(
   ['../ulib/FStar.Tactics.Types.fsti', addprefix('tactics/FStar.Tactics.','Types.fs Basic.fs Embedding.fs Native.fs'), 'boot/FStar.Tactics.Interpreter.fst'],
   'FStar.Tactics',
   'FStar.Tactics.Native')  # --no-extract FStar.Tactics.Native
   ),
  ('extract_reflection',ExtractNamespace(
   ['../ulib/FStar.Reflection.Types.fsti', addprefix('reflection/FStar.Reflection.','Basic.fs Data.fs Interpreter.fs')],
   'FStar.Reflection',
   'FStar.Reflection.Types')
   ),
  ('extract_smtencoding_base',ExtractNamespace(
   addprefix('smtencoding/FStar.SMTEncoding.','Term.fs Util.fs Z3.fs SplitQueryCases.fs ErrorReporting.fs'),
   'FStar.SMTEncoding')
   ),
  ('extract_encode',ExtractModule(
   'smtencoding/FStar.SMTEncoding.Encode.fs',
   'FStar.SMTEncoding.Encode')
   ),
  ('extract_solver',ExtractModule(
   'smtencoding/FStar.SMTEncoding.Solver.fs',
   'FStar.SMTEncoding.Solver')
   ),
  ('extract_fstar',ExtractModule(
   addprefix('fstar/FStar.','Dependencies.fs Legacy.Interactive.fs Interactive.fs Universal.fs Indent.fs Main.fs'),
   'FStar.Dependencies FStar.Interactive FStar.Legacy.Interactive FStar.Universal FStar.Indent FStar.Main')
   )
]

# List of handy target names that alias sets of targets listed above
ExtractionTargets = [
  ('extract_typechecker','extract_normalizer extract_rel extract_util extract_dmff extract_tcterm extract_tcinductive extract_tc'),
  ('extract_smtencoding','extract_smtencoding_base extract_encode extract_solver'),
  ('extract_all',        'extract_tactics extract_reflection extract_misc extract_syntax extract_parser extract_typechecker extract_tosyntax extract_smtencoding extract_extraction extract_fstar')
]

# Generate SCons targets for each Extraction entry
extraction_targets = {}
for name, e in Extractions:
  command = ' '.join(e.command)
  t_cmd = env.Command(e.targets, e.sources, '$FSTARBOOT $SOURCES ' + command)
  env.Depends(t_cmd, env['FSTAR'])  # take explicit dependency on the F* compiler executable
  env.Requires(t_cmd, boot_target)  # and boot_ files, they are includes for extraction
  env.Alias(name, t_cmd)            # create an alias to this command

# Turn the ExtractionTargets[] into actual SCons targets
for name, targets in ExtractionTargets:
  for t in targets.split(' '):
    env.Alias(name, t)
extract_target = env.Alias('extract', 'extract_all')

# --------------------------------------------------------------------

Return('boot_target', 'extract_target')
