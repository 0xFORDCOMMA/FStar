import re
import sys
import os, os.path
import subprocess
import traceback
import pdb
import shutil
import SCons.Util
import platform

Import("*")

execfile("SCons_Build_Errors.py")


AddOption('--CACHEDIR',
    dest='cache_dir',
    type='string',
    default=None,
    action='store',
    help='Specify the SCSons Shared Cache Directory')

cache_dir=GetOption('cache_dir')
if cache_dir == None:
    cache_dir = os.environ.get('EVEREST_SCONS_CACHE_DIR')
if cache_dir != None:
    print('Using Shared Cache Directory %s'%cache_dir)
    CacheDir(cache_dir)

    
    

# construct a default environment
env = Environment()

# --------------------------------------------------------------------
# Configuration of some platform-specific tools; eventually we will want a configure script

if sys.platform == 'win32' or sys.platform == 'cygwin':  # Windows 32-bit or 64-bit
    if sys.platform == 'cygwin':
        fd = open('/proc/registry/HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/MSBuild/ToolsVersions/14.0/MSBuildToolsPath', 'r')
        v = fd.read()
        v = v.rstrip(' \0') # strip the trailing \0 and any trailing whitespace
        fd.close()
    else:
        import _winreg
        k = _winreg.OpenKey(_winreg.HKEY_LOCAL_MACHINE, r'SOFTWARE\Microsoft\MSBuild\ToolsVersions\14.0')
        v = _winreg.QueryValueEx(k, 'MSBuildToolsPath')[0]
        k.Close()
    
    env['FSC']     = 'fsc'
    env['MSBUILD'] = '"'+os.path.join(v, 'MSBuild.exe')+'"'
    uname          = 'Windows_NT'

    # Copy the current fstar.exe to ExtractionFStar.exe so the ExtractionFStar.exe can be used
    # to run extraction to OCaml and fstar.exe can be the output target for the build, without
    # creating a circular dependency.
    #if os.path.exists('../bin/fstar.exe'):
    #    shutil.copy2('../bin/fstar.exe', '../bin/ExtractionFStar.exe')
    #env['FSTAR']   = '#/../bin/ExtractionFStar.exe'  # the path to the FStar binary

    env['FSTAR']   = '#/../bin/Fstar.exe'  # the path to the FStar binary
    env['RUNTIME'] = ''     # no Mono needed to run .NET code (FSLexYacc, etc.)
    env['FSTAR_RUNTIME']='' # no Mono needed to run the FStar compiler

    # propagate the TMP environment variable into the OS environment block used to launch
    # child processes.  nuget.exe uses TMP as the path to its lock file and falls back
    # on C:\WINDOWS if it doesn't exist, and that is readonly for most Windows users.
    env['ENV']['TMP'] = os.environ['TMP']
    
    # set the OS environment var in child processes.  MSBuild scripts like NuGet.targets consume it.
    env.AppendENVPath('OS', 'Windows_NT')  
else:
    env['FSC']     = 'fsharpc'
    env['MSBUILD'] = 'xbuild'
    uname          = os.uname()[0]  # sysname is at index 0
    env['RUNTIME'] = 'mono'
    # reproduce what fstar-any.sh does:
    l = os.readlink('../bin/fstar.exe')
    fstar = os.path.join(os.path.dirname('../bin'), l) # convert l to absolute path
    if os.path.exists(fstar):
        filetype = subprocess.check_output(['file',fstar])
        # Copy the current fstar.exe to ExtractionFStar.exe so the ExtractionFStar.exe can be used
        # to run extraction to OCaml and fstar.exe can be the output target for the build, without
        # creating a circular dependency.
        shutil.copy2(fstar, '../bin/ExtractionFStar.exe')
        env['FSTAR'] = File('#/../bin/ExtractionFStar.exe')  # the path to the FStar binary
        if filetype.contains('Mono'):                                   # how to execute the FStar binary
            env['FSTAR_RUNTIME'] = env['RUNTIME']  # it's the F# version
        else:
            env['FSTAR_RUNTIME'] = '' # it's the OCaml verion
    else:
        raise SCons.Errors.UserError('fstar.exe not found')
        
# propagate the OS PATH environment variable into child processes, so tools like menhir can be found  
env['ENV']['PATH']=os.environ['PATH']
env['BIN']=Dir('../bin')
env['CONFIGURATION']='Release'
env['MSBUILDARGS']='/verbosity:minimal /p:Configuration=$CONFIGURATION'
env['NUGET']=File('#/VS/.nuget/NuGet.exe')

Export('env')

# --------------------------------------------------------------------


# SConscript(['S_Local.py', 
#             'ocaml-output/S_Local.py'])

#top_NET = SConscript('FStar_NET.scons')                                 # vs-fstar
#no_prior, top_LKG = SConscript('ocaml-LKG/ocaml-output.scons')          # boot-ocaml , no prior 
#Ocaml_prior, top_Ocaml = SConscript('ocaml-output/ocaml-output.scons')  # ocaml
#FStar_prior, top_FStar = SConscript('FStar.scons')                      # extract

def Connect_Stages(prior):
    FStar_prior, top_FStar = SConscript('FStar.scons')
    if prior :  env.Depends(FStar_prior, prior)  
    #env.Default(top_FStar)
    env_OCaml  = env.Clone()
    Ocaml_prior, top_Ocaml = SConscript('ocaml-output.scons', exports={'My_env' : env_OCaml}, variant_dir='ocaml-output', duplicate=0)
    env.Depends(Ocaml_prior, top_FStar)
    return top_Ocaml

if 'vs-fstar' in COMMAND_LINE_TARGETS :
    top_NET = SConscript('FStar_NET.scons')
    vs_fstar = env.Alias('vs-fstar', top_NET)
    #env.Default(top_NET)
    pass
elif 'boot-ocaml' in COMMAND_LINE_TARGETS :
    no_prior, top_LKG = SConscript('ocaml-output.scons', exports={'My_env' : env}, variant_dir='ocaml-LKG', duplicate=0)
    boot_ocaml = env.Alias('boot-ocaml', top_LKG)
    #env.Default(top_LKG)
    pass
elif 'extract' in COMMAND_LINE_TARGETS :
    top_FStar = SConscript('FStar.scons')
    #env.Default(top_Fstar)
    pass
elif 'ocaml' in COMMAND_LINE_TARGETS :  # boot, extract, new ocaml
    top = Connect_Stages(None)
    env.Alias('ocaml', top)
    #env.Default(top)
    pass
elif 'all' in COMMAND_LINE_TARGETS :    # LKG ocaml, boot, extract, new ocaml
    env_LKG = env.Clone()
    no_prior, top_LKG = env_LKG.SConscript('ocaml-output.scons', exports={'My_env' : env_LKG}, variant_dir='ocaml-LKG', duplicate=0)
    if GetOption('clean') :
        top = Connect_Stages(None)
        all = env.Alias('all', [top, top_LKG])
        env.AlwaysBuild(top_LKG)
    else:
        top = Connect_Stages(top_LKG)
        all = env.Alias('all', [top_LKG, top])

    #all = env.Alias('all', [top_LKG, top])
    #all = env.Alias('all', top) if GetOption('clean') else env.Alias('all', [top_LKG, top])
    #all = env.Alias('all', top)
    #env.Default(all)
    pass

print("COMMAND_LINE_TARGETS: %s" % COMMAND_LINE_TARGETS)
print("DEFAULT_TARGETS: %s" % [a.name for a in DEFAULT_TARGETS])







if 0 : # easier then commenting out
        all = Alias('all', vs_fstar)

        Default(all)    # make the 'all' target be the default
        # Force the 'all' target to AlwaysBuild, so that MsBuild is invoked to do its own
        # evaluation of dependencies from the F# source code to fstar.exe.
        building_all = False
        if COMMAND_LINE_TARGETS:
            if 'all' in COMMAND_LINE_TARGETS:
                building_all = True
        else:
            if all[0] in DEFAULT_TARGETS:
                building_all = True
        if building_all:
            AlwaysBuild(nuget_restore)
            AlwaysBuild(install_packages)
            AlwaysBuild(vs_fstar)



# --------------------------------------------------------------------


# fstar-ocaml target:
#ml = env.MakeOcaml() # extract .fs to .ml using ExtractionFStar.exe
#fstar_ocaml = env.MakeOcamlOutput('FStar')
#env.Depends(fstar_ocaml, ml)
#Alias('fstar-ocaml', fstar_ocaml)

# ocaml-fstar-ocaml target
#extraction_fstar = env.MakeOcamlOutput('ExtractionFStar')
#ml = env.MakeOcaml()
#fstar_ocaml = env.MakeOcamlOutput('FStar')
#env.Depends(ml, extraction_fstar)
#env.Depends(fstar_ocaml, ml)
#Alias('ocaml-fstar-ocaml', fstar_ocaml)

# boot-ocaml
#env.Ignore(extraction_fstar)

