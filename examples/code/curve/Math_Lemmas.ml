
open Prims

let modulo_lemma_0 : Prims.nat  ->  Prims.pos  ->  Prims.unit = (fun a b -> ())


let euclidian_div_axiom : Prims.nat  ->  Prims.pos  ->  Prims.unit = (fun a b -> ())


let distributivity_add_left : Prims.int  ->  Prims.int  ->  Prims.int  ->  Prims.unit = (fun a b c -> ())


let distributivity_add_right : Prims.int  ->  Prims.int  ->  Prims.int  ->  Prims.unit = (fun a b c -> ())


let distributivity_sub_right : Prims.int  ->  Prims.int  ->  Prims.int  ->  Prims.unit = (fun a b c -> ())


let paren_mul_left : Prims.int  ->  Prims.int  ->  Prims.int  ->  Prims.unit = (fun a b c -> ())


let paren_mul_right : Prims.int  ->  Prims.int  ->  Prims.int  ->  Prims.unit = (fun a b c -> ())


let paren_add_left : Prims.int  ->  Prims.int  ->  Prims.int  ->  Prims.unit = (fun a b c -> ())


let paren_add_right : Prims.int  ->  Prims.int  ->  Prims.int  ->  Prims.unit = (fun a b c -> ())


let addition_is_associative : Prims.int  ->  Prims.int  ->  Prims.int  ->  Prims.unit = (fun a b c -> ())


let subtraction_is_distributive : Prims.int  ->  Prims.int  ->  Prims.int  ->  Prims.unit = (fun a b c -> ())


let swap_add_plus_minus : Prims.int  ->  Prims.int  ->  Prims.int  ->  Prims.unit = (fun a b c -> ())


let swap_mul : Prims.int  ->  Prims.int  ->  Prims.unit = (fun a b -> ())


let neg_mul_left : Prims.int  ->  Prims.int  ->  Prims.unit = (fun a b -> ())


let neg_mul_right : Prims.int  ->  Prims.int  ->  Prims.unit = (fun a b -> ())


let swap_neg_mul : Prims.int  ->  Prims.int  ->  Prims.unit = (fun a b -> ())


let mul_binds_tighter : Prims.int  ->  Prims.int  ->  Prims.int  ->  Prims.unit = (fun a b c -> ())


let mul_ineq1 : Prims.int  ->  Prims.nat  ->  Prims.int  ->  Prims.nat  ->  Prims.unit = (fun a b c d -> ())


let nat_times_nat_is_nat : Prims.nat  ->  Prims.nat  ->  Prims.unit = (fun a b -> ())


let pos_times_pos_is_pos : Prims.pos  ->  Prims.pos  ->  Prims.unit = (fun a b -> ())


let nat_over_pos_is_nat : Prims.nat  ->  Prims.pos  ->  Prims.unit = (fun a b -> ())


let pow2_double_sum : Prims.nat  ->  Prims.unit = (fun n -> ())


let pow2_double_mult : Prims.nat  ->  Prims.unit = (fun n -> ())


let rec pow2_increases_1 : Prims.nat  ->  Prims.nat  ->  Prims.unit = (fun n m -> ())


let pow2_increases_2 : Prims.nat  ->  Prims.nat  ->  Prims.unit = (fun n m -> ())


let aux_lemma_0 : Prims.nat  ->  Prims.nat  ->  Prims.unit = (fun n m -> ())


let aux_lemma_1 : Prims.nat  ->  Prims.unit = (fun n -> ())


let aux_lemma_2 : Prims.nat  ->  Prims.unit = (fun n -> ())


let rec pow2_exp_1 : Prims.nat  ->  Prims.nat  ->  Prims.unit = (fun n m -> ())


let nat_mul_1 : Prims.nat  ->  Prims.nat  ->  Prims.unit = (fun a b -> ())


let mul_pos_strict_incr : Prims.pos  ->  Prims.int  ->  Prims.pos  ->  Prims.unit = (fun a b c -> ())


let mul_incr : Prims.nat  ->  Prims.nat  ->  Prims.nat  ->  Prims.unit = (fun a b c -> ())


let multiply_fractions : Prims.nat  ->  Prims.pos  ->  Prims.unit = (fun a n -> ())


let paren_sub : Prims.int  ->  Prims.int  ->  Prims.int  ->  Prims.unit = (fun a b c -> ())


let non_zero_nat_is_pos : Prims.nat  ->  Prims.unit = (fun i -> ())


let non_zero_nat_is_pos_2 : Prims.nat  ->  Prims.unit = (fun n -> ())


let nat_plus_nat_is_nat : Prims.nat  ->  Prims.nat  ->  Prims.unit = (fun n m -> ())


let modulo_lemma : Prims.nat  ->  Prims.pos  ->  Prims.unit = (fun a b -> ())




