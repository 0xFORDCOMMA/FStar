{"query-id":"1","query":"push","args":{"kind":"full","code":"module Serializer\n","line":1,"column":0}}
{"query-id":"2","query":"push","args":{"kind":"full","code":"\nopen FStar.Seq\nopen FStar.HyperStack\nopen FStar.HyperStack.ST\nmodule B = FStar.Buffer\nmodule U16 = FStar.UInt16\nmodule U32 = FStar.UInt32\n","line":2,"column":0}}
{"query-id":"3","query":"push","args":{"kind":"full","code":"\nopen KeyValue\nopen Slice\nopen PureEncoder\n","line":9,"column":0}}
{"query-id":"4","query":"push","args":{"kind":"full","code":"\n(*! Efficient serializing *)\n\n(* NOTE: I'm using ser out of laziness, but they should NOT be abbreviated, we\ncan serialize everywhere *)\n\nlet offset_into (buf:bslice) = off:U32.t{U32.v off <= U32.v buf.len}\n","line":13,"column":0}}
{"query-id":"5","query":"push","args":{"kind":"full","code":"\nlet serialized (enc:bytes) (buf:bslice) (r:option (offset_into buf)) (h0 h1:mem) :\n    Pure Type0\n    (requires (live h1 buf))\n    (ensures (fun _ -> True)) =\n    match r with\n    | Some off ->\n      let (b1, b2) = bslice_split_at buf off in\n      modifies_slice b1 h0 h1 /\\\n      as_seq h1 b1 == enc\n    | None ->\n      modifies_slice buf h0 h1\n","line":20,"column":0}}
{"query-id":"6","query":"push","args":{"kind":"full","code":"\nlet buffer_fun (inputs:TSet.set bslice) =\n    f:(h:mem{forall b. TSet.mem b inputs ==> live h b} -> GTot bytes){\n      forall (h0 h1: h:mem{forall b. TSet.mem b inputs ==> live h b}).\n      (forall b. TSet.mem b inputs ==> as_seq h0 b == as_seq h1 b) ==>\n      f h0 == f h1}\n","line":32,"column":0}}
{"query-id":"7","query":"push","args":{"kind":"full","code":"\nlet disjoint_in (h:mem) (inputs:TSet.set bslice) (buf:bslice) =\n  forall b. TSet.mem b inputs ==> live h b /\\ B.disjoint b.p buf.p\n\nunfold\nlet serializer_any (inputs:TSet.set bslice)\n                   (enc: buffer_fun inputs) =\n  buf:bslice ->\n  ST (option (off:offset_into buf))\n     (requires (fun h0 -> live h0 buf /\\\n                       disjoint_in h0 inputs buf))\n     (ensures (fun h0 r h1 ->\n        live h0 buf /\\\n        live h1 buf /\\\n        (forall b. TSet.mem b inputs ==>\n           live h0 b /\\\n           live h1 b /\\\n           as_seq h0 b == as_seq h1 b) /\\\n        serialized (enc h1) buf r h0 h1))\n\nunfold\nlet serializer (enc:bytes) = serializer_any TSet.empty (fun _ -> enc)\n\nunfold\nlet serializer_1 (input:bslice) (enc: buffer_fun (TSet.singleton input)) =\n    serializer_any (TSet.singleton input) (fun h -> enc h)\n","line":38,"column":0}}
{"query-id":"8","query":"push","args":{"kind":"full","code":"\nlet lemma_index_upd_gt (#a:Type) (s:Seq.seq a) (n:nat{n < length s}) (i:nat{n < i /\\ i < length s}) (v:a) :\n  Lemma (index (Seq.upd s n v) i == index s i)\n  [SMTPat (index (Seq.upd s n v) i)] = ()\n","line":64,"column":0}}
{"query-id":"9","query":"push","args":{"kind":"full","code":"\n#reset-options \"--z3rlimit 10\"\n","line":68,"column":0}}
{"query-id":"10","query":"push","args":{"kind":"full","code":"\nval upd_len_1 : #a:Type -> s:Seq.seq a{length s == 1} -> v:a ->\n  Lemma (Seq.upd s 0 v == Seq.create 1 v)\nlet upd_len_1 #a s v =\n  lemma_eq_intro (Seq.upd s 0 v) (Seq.create 1 v)\n","line":70,"column":0}}
{"query-id":"11","query":"push","args":{"kind":"full","code":"\nval ser_byte: v:byte -> serializer (Seq.create 1 v)\nlet ser_byte v = fun buf ->\n  if U32.lt buf.len 1ul then None\n  else\n    let (buf, _) = bslice_split_at buf 1ul in\n    let h0 = get() in\n    B.upd buf.p 0ul v;\n    begin\n      let s0 = as_seq h0 buf in\n      upd_len_1 s0 v\n    end;\n    Some 1ul\n","line":75,"column":0}}
{"query-id":"12","query":"push","args":{"kind":"full","code":"\nlet upd_len_2 (#a:Type) (s:Seq.seq a{length s == 2}) (vs:Seq.seq a{length vs == 2}) :\n  Lemma (Seq.upd (Seq.upd s 0 (index vs 0)) 1 (index vs 1) == vs) =\n  lemma_eq_intro (Seq.upd (Seq.upd s 0 (index vs 0)) 1 (index vs 1)) vs\n","line":88,"column":0}}
{"query-id":"13","query":"push","args":{"kind":"full","code":"\nval ser_u16: v:U16.t -> serializer (u16_to_be v)\nlet ser_u16 v = fun buf ->\n  if U32.lt buf.len 2ul then None\n  else\n    let bs = u16_to_be v in\n    let (buf, _) = bslice_split_at buf 2ul in\n    let h0 = get() in\n    B.upd buf.p 0ul (index bs 0);\n    B.upd buf.p 1ul (index bs 1);\n    begin\n      let s0 = as_seq h0 buf in\n      upd_len_2 s0 bs\n    end;\n    Some 2ul\n","line":92,"column":0}}
{"query-id":"14","query":"push","args":{"kind":"full","code":"\nlet upd_len_4 (#a:Type) (s:Seq.seq a{length s == 4}) (vs:Seq.seq a{length vs == 4}) :\n  Lemma (Seq.upd\n          (Seq.upd\n            (Seq.upd\n              (Seq.upd s 0 (index vs 0))\n            1 (index vs 1))\n          2 (index vs 2))\n        3 (index vs 3) == vs) =\n  lemma_eq_intro (Seq.upd\n  (Seq.upd\n  (Seq.upd\n  (Seq.upd s 0 (index vs 0))\n  1 (index vs 1))\n  2 (index vs 2))\n  3 (index vs 3)) vs\n","line":107,"column":0}}
{"query-id":"15","query":"push","args":{"kind":"full","code":"\nval ser_u32: v:U32.t -> serializer (u32_to_be v)\nlet ser_u32 v = fun buf ->\n  if U32.lt buf.len 4ul then None\n  else\n    let bs = u32_to_be v in\n    let (buf, _) = bslice_split_at buf 4ul in\n    let h0 = get() in\n    B.upd buf.p 0ul (index bs 0);\n    B.upd buf.p 1ul (index bs 1);\n    B.upd buf.p 2ul (index bs 2);\n    B.upd buf.p 3ul (index bs 3);\n    begin\n      let s0 = as_seq h0 buf in\n      upd_len_4 s0 bs\n    end;\n    Some 4ul\n","line":123,"column":0}}
{"query-id":"16","query":"push","args":{"kind":"full","code":"\n// this is really a coercion that lifts a pure bytes serializer to one that\n// takes an input buffer (and ignores it)\nlet ser_input (input:bslice) (#b:bytes) (s:serializer b) : serializer_1 input (fun _ -> b) =\n    fun buf -> s buf\n","line":140,"column":0}}
{"query-id":"17","query":"push","args":{"kind":"full","code":"\n// coercion to increase the size of the inputs set\nlet ser_inputs (#inputs1:TSet.set bslice)\n               (inputs2:TSet.set bslice{TSet.subset inputs1 inputs2})\n               (#b: buffer_fun inputs1)\n               (s:serializer_any inputs1 b) : serializer_any inputs2 (fun h -> b h) =\n    fun buf -> s buf\n","line":145,"column":0}}
{"query-id":"18","query":"push","args":{"kind":"full","code":"\n#reset-options \"--z3rlimit 30\"\n","line":152,"column":0}}
{"query-id":"19","query":"push","args":{"kind":"full","code":"\nlet ser_append (#inputs1 #inputs2:TSet.set bslice)\n               (#b1: buffer_fun inputs1) (#b2: buffer_fun inputs2)\n               (s1:serializer_any inputs1 b1) (s2:serializer_any inputs2 b2) :\n               serializer_any (TSet.union inputs1 inputs2) (fun h -> append (b1 h) (b2 h)) =\n  fun buf ->\n  let h0 = get() in\n  match s1 buf with\n  | Some off ->\n    begin\n      let h1 = get() in\n      let buf0 = buf in\n      let (buf1, buf) = bslice_split_at buf off in\n      match s2 buf with\n      | Some off' -> (if u32_add_overflows off off' then None\n                     else begin\n                      begin\n                        let h2 = get() in\n                        let (buf2, buf3) = bslice_split_at buf off' in\n                        let (buf12, buf3') = bslice_split_at buf0 (U32.add off off') in\n                        assert (live h2 buf12);\n                        assert (as_seq h2 buf2 == b2 h2);\n                        assert (as_seq h2 buf1 == b1 h2);\n                        is_concat_append buf12.p buf1.p buf2.p h2;\n                        assert (as_seq h2 buf12 == append (b1 h2) (b2 h2));\n                        //assert (modifies_slice buf1 h0 h1);\n                        //assert (modifies_slice buf2 h1 h2);\n                        modifies_grow_from_b1 buf12 buf1 buf2 h0 h1;\n                        modifies_grow_from_b2 buf12 buf1 buf2 h1 h2;\n                        assert (modifies_slice buf12 h0 h2)\n                      end;\n                      Some (U32.add off off')\n                     end)\n      | None -> None\n    end\n  | None -> None\n\n#reset-options\n","line":154,"column":0}}
{"query-id":"20","query":"push","args":{"kind":"full","code":"\nval ser_copy : data:bslice -> serializer_1 data (fun h -> as_seq h data)\nlet ser_copy data = fun buf ->\n  if U32.lt buf.len data.len then None\n  else begin\n    let (buf1, buf2) = bslice_split_at buf data.len in\n    B.blit data.p 0ul buf1.p 0ul data.len;\n    Some data.len\n  end\n","line":192,"column":0}}
{"query-id":"21","query":"push","args":{"kind":"full","code":"\nlet enc_u16_array_st (a: u16_array_st) (h:mem{live h a.a16_st}) : GTot bytes =\n    u16_to_be a.len16_st `append` as_seq h a.a16_st\n","line":201,"column":0}}
{"query-id":"22","query":"peek","args":{"kind":"lax","code":"\n// inline_for_extraction unfold [@\"substitute\"]\nval ser_u16_array : a:u16_array_st ->\n  serializer_any (TSet.singleton a.a16_st) (fun h -> enc_u16_array_st a h)\nlet ser_u16_array a =\n  ser_inputs  (TSet.singleton a.a16_st) #(fun h -> enc_u16_array_st a h)\n  (ser_input a.a16_st (ser_u16 a.len16_st) `ser_append`\n   ser_copy a.a16_st)\n\nlet ser_u16_array' a input = ser_u16_array a input\n\nlet enc_u32_array_st (a: u32_array_st) (h:mem{live h a.a32_st}) : GTot bytes =\n  u32_to_be a.len32_st `append` as_seq h a.a32_st\n\n","line":204,"column":0}}
{"query-id":"23","query":"peek","args":{"kind":"lax","code":"\n// inline_for_extraction unfold [@\"substitute\"]\nval ser_u16_array : a:u16_array_st ->\n  serializer_any (TSet.singleton a.a16_st) (fun h -> enc_u16_array_st a h)\nlet ser_u16_array a =\n  ser_inputs (TSet.singleton a.a16_st) #(fun h -> enc_u16_array_st a h)\n  (ser_input a.a16_st (ser_u16 a.len16_st) `ser_append`\n   ser_copy a.a16_st)\n\nlet ser_u16_array' a input = ser_u16_array a input\n\nlet enc_u32_array_st (a: u32_array_st) (h:mem{live h a.a32_st}) : GTot bytes =\n  u32_to_be a.len32_st `append` as_seq h a.a32_st\n\n","line":204,"column":0}}
