;;; Started F* interactive: ("/Users/tchajed/code/sw/everest/FStar/bin/fstar.exe" "/Users/tchajed/code/sw/everest/FStar/examples/struct/keyvalue.pos/Serializer.fst" "--ide" "--smt" "/usr/local/bin/z3")
;;; Processing queue
>>> {"query-id":"1","query":"push","args":{"kind":"full","code":"module Serializer\n","line":1,"column":0}}
{"kind":"protocol-info","version":1,"features":["autocomplete","compute","describe-protocol","describe-repl","exit","lookup","lookup/documentation","lookup/definition","pop","peek","push","search"]}
;;; Complete message received: (status: nil; message: ((kind . "protocol-info") (version . 1) (features "autocomplete" "compute" "describe-protocol" "describe-repl" "exit" "lookup" "lookup/documentation" "lookup/definition" "pop" "peek" "push" "search")))
{"kind":"message","level":"info","contents":"Desugared attribute: \"substitute\"\n"}
{"kind":"message","level":"info","contents":"Desugared attribute: \"substitute\"\n"}
;;; Complete message received: (status: nil; message: ((kind . "message") (level . "info") (contents . "Desugared attribute: \"substitute\"
;;; ")))
;;; Complete message received: (status: nil; message: ((kind . "message") (level . "info") (contents . "Desugared attribute: \"substitute\"
;;; ")))
{"kind":"response","query-id":"1","status":"success","response":[]}
;;; Complete message received: (status: "success"; message: ((kind . "response") (query-id . "1") (status . "success") (response)))
;;; Processing queue
>>> {"query-id":"2","query":"push","args":{"kind":"full","code":"\nopen FStar.Seq\nopen FStar.HyperStack\nopen FStar.HyperStack.ST\nmodule B = FStar.Buffer\nmodule U16 = FStar.UInt16\nmodule U32 = FStar.UInt32\n","line":2,"column":0}}
{"kind":"response","query-id":"2","status":"success","response":[]}
;;; Complete message received: (status: "success"; message: ((kind . "response") (query-id . "2") (status . "success") (response)))
;;; Processing queue
>>> {"query-id":"3","query":"push","args":{"kind":"full","code":"\nopen KeyValue\nopen Slice\nopen PureEncoder\n","line":9,"column":0}}
{"kind":"response","query-id":"3","status":"success","response":[]}
;;; Complete message received: (status: "success"; message: ((kind . "response") (query-id . "3") (status . "success") (response)))
;;; Processing queue
>>> {"query-id":"4","query":"push","args":{"kind":"full","code":"\n(*! Efficient serializing *)\n\n(* NOTE: I'm using ser out of laziness, but they should NOT be abbreviated, we\ncan serialize everywhere *)\n\nlet offset_into (buf:bslice) = off:U32.t{U32.v off <= U32.v buf.len}\n","line":13,"column":0}}
{"kind":"response","query-id":"4","status":"success","response":[]}
;;; Complete message received: (status: "success"; message: ((kind . "response") (query-id . "4") (status . "success") (response)))
;;; Processing queue
>>> {"query-id":"5","query":"push","args":{"kind":"full","code":"\nlet serialized (enc:bytes) (buf:bslice) (r:option (offset_into buf)) (h0 h1:mem) :\n    Pure Type0\n    (requires (live h1 buf))\n    (ensures (fun _ -> True)) =\n    match r with\n    | Some off ->\n      let (b1, b2) = bslice_split_at buf off in\n      modifies_slice b1 h0 h1 /\\\n      as_seq h1 b1 == enc\n    | None ->\n      modifies_slice buf h0 h1\n","line":20,"column":0}}
{"kind":"response","query-id":"5","status":"success","response":[]}
;;; Complete message received: (status: "success"; message: ((kind . "response") (query-id . "5") (status . "success") (response)))
;;; Processing queue
>>> {"query-id":"6","query":"push","args":{"kind":"full","code":"\nlet buffer_fun (inputs:TSet.set bslice) =\n    f:(h:mem{forall b. TSet.mem b inputs ==> live h b} -> GTot bytes){\n      forall (h0 h1: h:mem{forall b. TSet.mem b inputs ==> live h b}).\n      (forall b. TSet.mem b inputs ==> as_seq h0 b == as_seq h1 b) ==>\n      f h0 == f h1}\n","line":32,"column":0}}
{"kind":"response","query-id":"6","status":"success","response":[]}
;;; Complete message received: (status: "success"; message: ((kind . "response") (query-id . "6") (status . "success") (response)))
;;; Processing queue
>>> {"query-id":"7","query":"push","args":{"kind":"full","code":"\nlet disjoint_in (h:mem) (inputs:TSet.set bslice) (buf:bslice) =\n  forall b. TSet.mem b inputs ==> live h b /\\ B.disjoint b.p buf.p\n\nunfold\nlet serializer_any (inputs:TSet.set bslice)\n                   (enc: buffer_fun inputs) =\n  buf:bslice ->\n  ST (option (off:offset_into buf))\n     (requires (fun h0 -> live h0 buf /\\\n                       disjoint_in h0 inputs buf))\n     (ensures (fun h0 r h1 ->\n        live h0 buf /\\\n        live h1 buf /\\\n        (forall b. TSet.mem b inputs ==>\n           live h0 b /\\\n           live h1 b /\\\n           as_seq h0 b == as_seq h1 b) /\\\n        serialized (enc h1) buf r h0 h1))\n\nunfold\nlet serializer (enc:bytes) = serializer_any TSet.empty (fun _ -> enc)\n\nunfold\nlet serializer_1 (input:bslice) (enc: buffer_fun (TSet.singleton input)) =\n    serializer_any (TSet.singleton input) (fun h -> enc h)\n","line":38,"column":0}}
{"kind":"response","query-id":"7","status":"success","response":[]}
;;; Complete message received: (status: "success"; message: ((kind . "response") (query-id . "7") (status . "success") (response)))
;;; Processing queue
>>> {"query-id":"8","query":"push","args":{"kind":"full","code":"\nlet lemma_index_upd_gt (#a:Type) (s:Seq.seq a) (n:nat{n < length s}) (i:nat{n < i /\\ i < length s}) (v:a) :\n  Lemma (index (Seq.upd s n v) i == index s i)\n  [SMTPat (index (Seq.upd s n v) i)] = ()\n","line":64,"column":0}}
{"kind":"response","query-id":"8","status":"success","response":[]}
;;; Complete message received: (status: "success"; message: ((kind . "response") (query-id . "8") (status . "success") (response)))
;;; Processing queue
>>> {"query-id":"9","query":"push","args":{"kind":"full","code":"\n#reset-options \"--z3rlimit 10\"\n","line":68,"column":0}}
{"kind":"response","query-id":"9","status":"success","response":[]}
;;; Complete message received: (status: "success"; message: ((kind . "response") (query-id . "9") (status . "success") (response)))
;;; Processing queue
>>> {"query-id":"10","query":"push","args":{"kind":"full","code":"\nval upd_len_1 : #a:Type -> s:Seq.seq a{length s == 1} -> v:a ->\n  Lemma (Seq.upd s 0 v == Seq.create 1 v)\nlet upd_len_1 #a s v =\n  lemma_eq_intro (Seq.upd s 0 v) (Seq.create 1 v)\n","line":70,"column":0}}
{"kind":"response","query-id":"10","status":"success","response":[]}
;;; Complete message received: (status: "success"; message: ((kind . "response") (query-id . "10") (status . "success") (response)))
;;; Processing queue
>>> {"query-id":"11","query":"push","args":{"kind":"full","code":"\nval ser_byte: v:byte -> serializer (Seq.create 1 v)\nlet ser_byte v = fun buf ->\n  if U32.lt buf.len 1ul then None\n  else\n    let (buf, _) = bslice_split_at buf 1ul in\n    let h0 = get() in\n    B.upd buf.p 0ul v;\n    begin\n      let s0 = as_seq h0 buf in\n      upd_len_1 s0 v\n    end;\n    Some 1ul\n","line":75,"column":0}}
{"kind":"response","query-id":"11","status":"success","response":[]}
;;; Complete message received: (status: "success"; message: ((kind . "response") (query-id . "11") (status . "success") (response)))
;;; Processing queue
>>> {"query-id":"12","query":"push","args":{"kind":"full","code":"\nlet upd_len_2 (#a:Type) (s:Seq.seq a{length s == 2}) (vs:Seq.seq a{length vs == 2}) :\n  Lemma (Seq.upd (Seq.upd s 0 (index vs 0)) 1 (index vs 1) == vs) =\n  lemma_eq_intro (Seq.upd (Seq.upd s 0 (index vs 0)) 1 (index vs 1)) vs\n","line":88,"column":0}}
{"kind":"response","query-id":"12","status":"success","response":[]}
;;; Complete message received: (status: "success"; message: ((kind . "response") (query-id . "12") (status . "success") (response)))
;;; Processing queue
>>> {"query-id":"13","query":"push","args":{"kind":"full","code":"\nval ser_u16: v:U16.t -> serializer (u16_to_be v)\nlet ser_u16 v = fun buf ->\n  if U32.lt buf.len 2ul then None\n  else\n    let bs = u16_to_be v in\n    let (buf, _) = bslice_split_at buf 2ul in\n    let h0 = get() in\n    B.upd buf.p 0ul (index bs 0);\n    B.upd buf.p 1ul (index bs 1);\n    begin\n      let s0 = as_seq h0 buf in\n      upd_len_2 s0 bs\n    end;\n    Some 2ul\n","line":92,"column":0}}
{"kind":"response","query-id":"13","status":"success","response":[]}
;;; Complete message received: (status: "success"; message: ((kind . "response") (query-id . "13") (status . "success") (response)))
;;; Processing queue
>>> {"query-id":"14","query":"push","args":{"kind":"full","code":"\nlet upd_len_4 (#a:Type) (s:Seq.seq a{length s == 4}) (vs:Seq.seq a{length vs == 4}) :\n  Lemma (Seq.upd\n          (Seq.upd\n            (Seq.upd\n              (Seq.upd s 0 (index vs 0))\n            1 (index vs 1))\n          2 (index vs 2))\n        3 (index vs 3) == vs) =\n  lemma_eq_intro (Seq.upd\n  (Seq.upd\n  (Seq.upd\n  (Seq.upd s 0 (index vs 0))\n  1 (index vs 1))\n  2 (index vs 2))\n  3 (index vs 3)) vs\n","line":107,"column":0}}
{"kind":"response","query-id":"14","status":"success","response":[]}
;;; Complete message received: (status: "success"; message: ((kind . "response") (query-id . "14") (status . "success") (response)))
;;; Processing queue
>>> {"query-id":"15","query":"push","args":{"kind":"full","code":"\nval ser_u32: v:U32.t -> serializer (u32_to_be v)\nlet ser_u32 v = fun buf ->\n  if U32.lt buf.len 4ul then None\n  else\n    let bs = u32_to_be v in\n    let (buf, _) = bslice_split_at buf 4ul in\n    let h0 = get() in\n    B.upd buf.p 0ul (index bs 0);\n    B.upd buf.p 1ul (index bs 1);\n    B.upd buf.p 2ul (index bs 2);\n    B.upd buf.p 3ul (index bs 3);\n    begin\n      let s0 = as_seq h0 buf in\n      upd_len_4 s0 bs\n    end;\n    Some 4ul\n","line":123,"column":0}}
{"kind":"response","query-id":"15","status":"success","response":[]}
;;; Complete message received: (status: "success"; message: ((kind . "response") (query-id . "15") (status . "success") (response)))
;;; Processing queue
>>> {"query-id":"16","query":"push","args":{"kind":"full","code":"\n// this is really a coercion that lifts a pure bytes serializer to one that\n// takes an input buffer (and ignores it)\nlet ser_input (input:bslice) (#b:bytes) (s:serializer b) : serializer_1 input (fun _ -> b) =\n    fun buf -> s buf\n","line":140,"column":0}}
{"kind":"response","query-id":"16","status":"success","response":[]}
;;; Complete message received: (status: "success"; message: ((kind . "response") (query-id . "16") (status . "success") (response)))
;;; Processing queue
>>> {"query-id":"17","query":"push","args":{"kind":"full","code":"\n// coercion to increase the size of the inputs set\nlet ser_inputs (#inputs1:TSet.set bslice)\n               (inputs2:TSet.set bslice{TSet.subset inputs1 inputs2})\n               (#b: buffer_fun inputs1)\n               (s:serializer_any inputs1 b) : serializer_any inputs2 (fun h -> b h) =\n    fun buf -> s buf\n","line":145,"column":0}}
{"kind":"response","query-id":"17","status":"success","response":[]}
;;; Complete message received: (status: "success"; message: ((kind . "response") (query-id . "17") (status . "success") (response)))
;;; Processing queue
>>> {"query-id":"18","query":"push","args":{"kind":"full","code":"\n#reset-options \"--z3rlimit 30\"\n","line":152,"column":0}}
{"kind":"response","query-id":"18","status":"success","response":[]}
;;; Complete message received: (status: "success"; message: ((kind . "response") (query-id . "18") (status . "success") (response)))
;;; Processing queue
>>> {"query-id":"19","query":"push","args":{"kind":"full","code":"\nlet ser_append (#inputs1 #inputs2:TSet.set bslice)\n               (#b1: buffer_fun inputs1) (#b2: buffer_fun inputs2)\n               (s1:serializer_any inputs1 b1) (s2:serializer_any inputs2 b2) :\n               serializer_any (TSet.union inputs1 inputs2) (fun h -> append (b1 h) (b2 h)) =\n  fun buf ->\n  let h0 = get() in\n  match s1 buf with\n  | Some off ->\n    begin\n      let h1 = get() in\n      let buf0 = buf in\n      let (buf1, buf) = bslice_split_at buf off in\n      match s2 buf with\n      | Some off' -> (if u32_add_overflows off off' then None\n                     else begin\n                      begin\n                        let h2 = get() in\n                        let (buf2, buf3) = bslice_split_at buf off' in\n                        let (buf12, buf3') = bslice_split_at buf0 (U32.add off off') in\n                        assert (live h2 buf12);\n                        assert (as_seq h2 buf2 == b2 h2);\n                        assert (as_seq h2 buf1 == b1 h2);\n                        is_concat_append buf12.p buf1.p buf2.p h2;\n                        assert (as_seq h2 buf12 == append (b1 h2) (b2 h2));\n                        //assert (modifies_slice buf1 h0 h1);\n                        //assert (modifies_slice buf2 h1 h2);\n                        modifies_grow_from_b1 buf12 buf1 buf2 h0 h1;\n                        modifies_grow_from_b2 buf12 buf1 buf2 h1 h2;\n                        assert (modifies_slice buf12 h0 h2)\n                      end;\n                      Some (U32.add off off')\n                     end)\n      | None -> None\n    end\n  | None -> None\n\n#reset-options\n","line":154,"column":0}}
{"kind":"response","query-id":"19","status":"success","response":[]}
;;; Complete message received: (status: "success"; message: ((kind . "response") (query-id . "19") (status . "success") (response)))
;;; Processing queue
>>> {"query-id":"20","query":"push","args":{"kind":"full","code":"\nval ser_copy : data:bslice -> serializer_1 data (fun h -> as_seq h data)\nlet ser_copy data = fun buf ->\n  if U32.lt buf.len data.len then None\n  else begin\n    let (buf1, buf2) = bslice_split_at buf data.len in\n    B.blit data.p 0ul buf1.p 0ul data.len;\n    Some data.len\n  end\n","line":192,"column":0}}
{"kind":"response","query-id":"20","status":"success","response":[]}
;;; Complete message received: (status: "success"; message: ((kind . "response") (query-id . "20") (status . "success") (response)))
;;; Processing queue
>>> {"query-id":"21","query":"push","args":{"kind":"full","code":"\nlet enc_u16_array_st (a: u16_array_st) (h:mem{live h a.a16_st}) : GTot bytes =\n    u16_to_be a.len16_st `append` as_seq h a.a16_st\n","line":201,"column":0}}
{"kind":"response","query-id":"21","status":"success","response":[]}
;;; Complete message received: (status: "success"; message: ((kind . "response") (query-id . "21") (status . "success") (response)))
;;; Queue is empty (21 overlays)
>>> {"query-id":"22","query":"lookup","args":{"symbol":"ser_u16_array","requested-info":["type","documentation"],"location":{"filename":"<input>","line":206,"column":8}}}
{"kind":"response","query-id":"22","status":"failure","response":null}
;;; Complete message received: (status: "failure"; message: ((kind . "response") (query-id . "22") (status . "failure") (response . :json-null)))
;;; [3.46ms] Fetched results for [cl-struct-fstar-subp-query "lookup" (("symbol" . "ser_u16_array") ("requested-info" type documentation) ("location" ("filename" . "<input>") ("line" . 206) ("column" . 8)))]
;;; Queue is empty (21 overlays)
>>> {"query-id":"23","query":"lookup","args":{"symbol":"","requested-info":["type","documentation"],"location":{"filename":"<input>","line":206,"column":19}}}
{"kind":"response","query-id":"23","status":"failure","response":null}
;;; Complete message received: (status: "failure"; message: ((kind . "response") (query-id . "23") (status . "failure") (response . :json-null)))
;;; [3.98ms] Fetched results for [cl-struct-fstar-subp-query "lookup" (("symbol" . "") ("requested-info" type documentation) ("location" ("filename" . "<input>") ("line" . 206) ("column" . 19)))]
;;; Queue is empty (21 overlays)
>>> {"query-id":"24","query":"lookup","args":{"symbol":"inline_for_extraction","requested-info":["type","documentation"],"location":{"filename":"<input>","line":205,"column":19}}}
{"kind":"response","query-id":"24","status":"failure","response":null}
;;; Complete message received: (status: "failure"; message: ((kind . "response") (query-id . "24") (status . "failure") (response . :json-null)))
;;; [4.25ms] Fetched results for [cl-struct-fstar-subp-query "lookup" (("symbol" . "inline_for_extraction") ("requested-info" type documentation) ("location" ("filename" . "<input>") ("line" . 205) ("column" . 19)))]
;;; Queue is empty (21 overlays)
>>> {"query-id":"25","query":"lookup","args":{"symbol":"inline_for_extraction","requested-info":["type","documentation"],"location":{"filename":"<input>","line":205,"column":20}}}
{"kind":"response","query-id":"25","status":"failure","response":null}
;;; Complete message received: (status: "failure"; message: ((kind . "response") (query-id . "25") (status . "failure") (response . :json-null)))
;;; [4.04ms] Fetched results for [cl-struct-fstar-subp-query "lookup" (("symbol" . "inline_for_extraction") ("requested-info" type documentation) ("location" ("filename" . "<input>") ("line" . 205) ("column" . 20)))]
;;; Queue is empty (21 overlays)
>>> {"query-id":"26","query":"lookup","args":{"symbol":"unfold","requested-info":["type","documentation"],"location":{"filename":"<input>","line":205,"column":27}}}
{"kind":"response","query-id":"26","status":"failure","response":null}
;;; Complete message received: (status: "failure"; message: ((kind . "response") (query-id . "26") (status . "failure") (response . :json-null)))
;;; [4.01ms] Fetched results for [cl-struct-fstar-subp-query "lookup" (("symbol" . "unfold") ("requested-info" type documentation) ("location" ("filename" . "<input>") ("line" . 205) ("column" . 27)))]
;;; Queue is empty (21 overlays)
>>> {"query-id":"27","query":"lookup","args":{"symbol":"unfold","requested-info":["type","documentation"],"location":{"filename":"<input>","line":205,"column":28}}}
{"kind":"response","query-id":"27","status":"failure","response":null}
;;; Complete message received: (status: "failure"; message: ((kind . "response") (query-id . "27") (status . "failure") (response . :json-null)))
;;; [4.02ms] Fetched results for [cl-struct-fstar-subp-query "lookup" (("symbol" . "unfold") ("requested-info" type documentation) ("location" ("filename" . "<input>") ("line" . 205) ("column" . 28)))]
;;; Queue is empty (21 overlays)
>>> {"query-id":"28","query":"lookup","args":{"symbol":"substitute","requested-info":["type","documentation"],"location":{"filename":"<input>","line":205,"column":37}}}
{"kind":"response","query-id":"28","status":"failure","response":null}
;;; Complete message received: (status: "failure"; message: ((kind . "response") (query-id . "28") (status . "failure") (response . :json-null)))
;;; [4.08ms] Fetched results for [cl-struct-fstar-subp-query "lookup" (("symbol" . "substitute") ("requested-info" type documentation) ("location" ("filename" . "<input>") ("line" . 205) ("column" . 37)))]
;;; Queue is empty (21 overlays)
>>> {"query-id":"29","query":"lookup","args":{"symbol":"","requested-info":["type","documentation"],"location":{"filename":"<input>","line":206,"column":37}}}
{"kind":"response","query-id":"29","status":"failure","response":null}
;;; Complete message received: (status: "failure"; message: ((kind . "response") (query-id . "29") (status . "failure") (response . :json-null)))
;;; [3.91ms] Fetched results for [cl-struct-fstar-subp-query "lookup" (("symbol" . "") ("requested-info" type documentation) ("location" ("filename" . "<input>") ("line" . 206) ("column" . 37)))]
;;; Queue is empty (21 overlays)
>>> {"query-id":"30","query":"lookup","args":{"symbol":"a.a16_st","requested-info":["type","documentation"],"location":{"filename":"<input>","line":207,"column":37}}}
{"kind":"response","query-id":"30","status":"failure","response":null}
;;; Complete message received: (status: "failure"; message: ((kind . "response") (query-id . "30") (status . "failure") (response . :json-null)))
;;; [3.89ms] Fetched results for [cl-struct-fstar-subp-query "lookup" (("symbol" . "a.a16_st") ("requested-info" type documentation) ("location" ("filename" . "<input>") ("line" . 207) ("column" . 37)))]
;;; Queue is empty (21 overlays)
>>> {"query-id":"31","query":"lookup","args":{"symbol":"","requested-info":["type","documentation"],"location":{"filename":"<input>","line":207,"column":0}}}
{"kind":"response","query-id":"31","status":"failure","response":null}
;;; Complete message received: (status: "failure"; message: ((kind . "response") (query-id . "31") (status . "failure") (response . :json-null)))
;;; [3.87ms] Fetched results for [cl-struct-fstar-subp-query "lookup" (("symbol" . "") ("requested-info" type documentation) ("location" ("filename" . "<input>") ("line" . 207) ("column" . 0)))]
;;; Queue is empty (21 overlays)
>>> {"query-id":"32","query":"lookup","args":{"symbol":"","requested-info":["type","documentation"],"location":{"filename":"<input>","line":207,"column":1}}}
{"kind":"response","query-id":"32","status":"failure","response":null}
;;; Complete message received: (status: "failure"; message: ((kind . "response") (query-id . "32") (status . "failure") (response . :json-null)))
;;; [3.93ms] Fetched results for [cl-struct-fstar-subp-query "lookup" (("symbol" . "") ("requested-info" type documentation) ("location" ("filename" . "<input>") ("line" . 207) ("column" . 1)))]
;;; Queue is empty (21 overlays)
>>> {"query-id":"33","query":"lookup","args":{"symbol":"serializer_any","requested-info":["type","documentation"],"location":{"filename":"<input>","line":207,"column":2}}}
{"kind":"response","query-id":"33","status":"success","response":{"name":"Serializer.serializer_any","defined-at":null,"type":"inputs:FStar.TSet.set Slice.bslice -> enc:Serializer.buffer_fun inputs -> Prims.Tot Type0","documentation":null,"definition":null}}
;;; Complete message received: (status: "success"; message: ((kind . "response") (query-id . "33") (status . "success") (response (name . "Serializer.serializer_any") (defined-at . :json-null) (type . "inputs:FStar.TSet.set Slice.bslice -> enc:Serializer.buffer_fun inputs -> Prims.Tot Type0") (documentation . :json-null) (definition . :json-null))))
;;; [4.10ms] Fetched results for [cl-struct-fstar-subp-query "lookup" (("symbol" . "serializer_any") ("requested-info" type documentation) ("location" ("filename" . "<input>") ("line" . 207) ("column" . 2)))]
;;; Queue is empty (21 overlays)
>>> {"query-id":"34","query":"lookup","args":{"symbol":"serializer_any","requested-info":["type","documentation"],"location":{"filename":"<input>","line":207,"column":3}}}
{"kind":"response","query-id":"34","status":"success","response":{"name":"Serializer.serializer_any","defined-at":null,"type":"inputs:FStar.TSet.set Slice.bslice -> enc:Serializer.buffer_fun inputs -> Prims.Tot Type0","documentation":null,"definition":null}}
;;; Complete message received: (status: "success"; message: ((kind . "response") (query-id . "34") (status . "success") (response (name . "Serializer.serializer_any") (defined-at . :json-null) (type . "inputs:FStar.TSet.set Slice.bslice -> enc:Serializer.buffer_fun inputs -> Prims.Tot Type0") (documentation . :json-null) (definition . :json-null))))
;;; [4.09ms] Fetched results for [cl-struct-fstar-subp-query "lookup" (("symbol" . "serializer_any") ("requested-info" type documentation) ("location" ("filename" . "<input>") ("line" . 207) ("column" . 3)))]
;;; Queue is empty (21 overlays)
>>> {"query-id":"35","query":"peek","args":{"kind":"lax","code":"\n// inline_for_extraction unfold [@\"substitute\"]\nval ser_u16_array : a:u16_array_st ->\n  serializer_any (TSet.singleton a.a16_st) (fun h -> enc_u16_array_st a h)\nlet ser_u16_array a =\n  ser_inputs (TSet.singleton a.a16_st) #(fun h -> enc_u16_array_st a h)\n  (ser_input a.a16_st (ser_u16 a.len16_st) `ser_append`\n   ser_copy a.a16_st)\n\nlet ser_u16_array' a input = ser_u16_array a input\n\nlet enc_u32_array_st (a: u32_array_st) (h:mem{live h a.a32_st}) : GTot bytes =\n  u32_to_be a.len32_st `append` as_seq h a.a32_st\n\n","line":204,"column":0}}
{"kind":"response","query-id":"35","status":"success","response":[{"level":"error","message":"Failed to resolve implicit argument of type 'FStar.TSet.set Slice.bslice' introduced in uu___unification_ 0 a","ranges":[{"fname":"<input>","beg":[209,2],"end":[209,12]}]}]}
;;; Complete message received: (status: "success"; message: ((kind . "response") (query-id . "35") (status . "success") (response ((level . "error") (message . "Failed to resolve implicit argument of type 'FStar.TSet.set Slice.bslice' introduced in uu___unification_ 0 a") (ranges ((fname . "<input>") (beg 209 2) (end 209 12)))))))
;;; Highlighting Flycheck issues: ([cl-struct-fstar-issue error ([cl-struct-fstar-location "/Users/tchajed/code/sw/everest/FStar/examples/struct/keyvalue.pos/Serializer.fst" 209 209 2 12]) "Failed to resolve implicit argument of type 'FStar.TSet.set Slice.bslice' introduced in uu___unification_ 0 a"])
;;; Queue is empty (21 overlays)
>>> {"query-id":"36","query":"lookup","args":{"symbol":"let","requested-info":["type","documentation"],"location":{"filename":"<input>","line":208,"column":3}}}
{"kind":"response","query-id":"36","status":"failure","response":null}
;;; Complete message received: (status: "failure"; message: ((kind . "response") (query-id . "36") (status . "failure") (response . :json-null)))
;;; [4.02ms] Fetched results for [cl-struct-fstar-subp-query "lookup" (("symbol" . "let") ("requested-info" type documentation) ("location" ("filename" . "<input>") ("line" . 208) ("column" . 3)))]
;;; Queue is empty (21 overlays)
>>> {"query-id":"37","query":"lookup","args":{"symbol":"ser_inputs","requested-info":["type","documentation"],"location":{"filename":"<input>","line":209,"column":3}}}
{"kind":"response","query-id":"37","status":"success","response":{"name":"Serializer.ser_inputs","defined-at":null,"type":"inputs2:FStar.TSet.set Slice.bslice{ FStar.TSet.subset inputs1 inputs2 } ->\ns:\n(buf:Slice.bslice ->\n  FStar.HyperStack.ST.ST (FStar.Pervasives.Native.option (Serializer.offset_into buf))) ->\nPrims.Tot\n(buf:Slice.bslice ->\n  FStar.HyperStack.ST.ST (FStar.Pervasives.Native.option (Serializer.offset_into buf)))","documentation":null,"definition":null}}
;;; Complete message received: (status: "success"; message: ((kind . "response") (query-id . "37") (status . "success") (response (name . "Serializer.ser_inputs") (defined-at . :json-null) (type . "inputs2:FStar.TSet.set Slice.bslice{ FStar.TSet.subset inputs1 inputs2 } ->
;;; s:
;;; (buf:Slice.bslice ->
;;;   FStar.HyperStack.ST.ST (FStar.Pervasives.Native.option (Serializer.offset_into buf))) ->
;;; Prims.Tot
;;; (buf:Slice.bslice ->
;;;   FStar.HyperStack.ST.ST (FStar.Pervasives.Native.option (Serializer.offset_into buf)))") (documentation . :json-null) (definition . :json-null))))
;;; [4.35ms] Fetched results for [cl-struct-fstar-subp-query "lookup" (("symbol" . "ser_inputs") ("requested-info" type documentation) ("location" ("filename" . "<input>") ("line" . 209) ("column" . 3)))]
;;; Queue is empty (21 overlays)
>>> {"query-id":"38","query":"lookup","args":{"symbol":"ser_inputs","requested-info":["type","documentation"],"location":{"filename":"<input>","line":209,"column":4}}}
{"kind":"response","query-id":"38","status":"success","response":{"name":"Serializer.ser_inputs","defined-at":null,"type":"inputs2:FStar.TSet.set Slice.bslice{ FStar.TSet.subset inputs1 inputs2 } ->\ns:\n(buf:Slice.bslice ->\n  FStar.HyperStack.ST.ST (FStar.Pervasives.Native.option (Serializer.offset_into buf))) ->\nPrims.Tot\n(buf:Slice.bslice ->\n  FStar.HyperStack.ST.ST (FStar.Pervasives.Native.option (Serializer.offset_into buf)))","documentation":null,"definition":null}}
;;; Complete message received: (status: "success"; message: ((kind . "response") (query-id . "38") (status . "success") (response (name . "Serializer.ser_inputs") (defined-at . :json-null) (type . "inputs2:FStar.TSet.set Slice.bslice{ FStar.TSet.subset inputs1 inputs2 } ->
;;; s:
;;; (buf:Slice.bslice ->
;;;   FStar.HyperStack.ST.ST (FStar.Pervasives.Native.option (Serializer.offset_into buf))) ->
;;; Prims.Tot
;;; (buf:Slice.bslice ->
;;;   FStar.HyperStack.ST.ST (FStar.Pervasives.Native.option (Serializer.offset_into buf)))") (documentation . :json-null) (definition . :json-null))))
;;; [4.29ms] Fetched results for [cl-struct-fstar-subp-query "lookup" (("symbol" . "ser_inputs") ("requested-info" type documentation) ("location" ("filename" . "<input>") ("line" . 209) ("column" . 4)))]
;;; Queue is empty (21 overlays)
>>> {"query-id":"39","query":"lookup","args":{"symbol":"","requested-info":["type","documentation"],"location":{"filename":"<input>","line":209,"column":13}}}
{"kind":"response","query-id":"39","status":"failure","response":null}
;;; Complete message received: (status: "failure"; message: ((kind . "response") (query-id . "39") (status . "failure") (response . :json-null)))
;;; [4.07ms] Fetched results for [cl-struct-fstar-subp-query "lookup" (("symbol" . "") ("requested-info" type documentation) ("location" ("filename" . "<input>") ("line" . 209) ("column" . 13)))]
;;; Queue is empty (21 overlays)
>>> {"query-id":"40","query":"lookup","args":{"symbol":"TSet.singleton","requested-info":["type","documentation"],"location":{"filename":"<input>","line":209,"column":14}}}
{"kind":"response","query-id":"40","status":"success","response":{"name":"FStar.TSet.singleton","defined-at":null,"type":"x:'a -> Prims.Tot (FStar.TSet.set 'a)","documentation":null,"definition":null}}
;;; Complete message received: (status: "success"; message: ((kind . "response") (query-id . "40") (status . "success") (response (name . "FStar.TSet.singleton") (defined-at . :json-null) (type . "x:'a -> Prims.Tot (FStar.TSet.set 'a)") (documentation . :json-null) (definition . :json-null))))
;;; [4.13ms] Fetched results for [cl-struct-fstar-subp-query "lookup" (("symbol" . "TSet.singleton") ("requested-info" type documentation) ("location" ("filename" . "<input>") ("line" . 209) ("column" . 14)))]
;;; Queue is empty (21 overlays)
>>> {"query-id":"41","query":"peek","args":{"kind":"lax","code":"\n// inline_for_extraction unfold [@\"substitute\"]\nval ser_u16_array : a:u16_array_st ->\n  serializer_any (TSet.singleton a.a16_st) (fun h -> enc_u16_array_st a h)\nlet ser_u16_array a =\n  ser_inputs (TSet.singleton a.a16_st) #(fun h -> enc_u16_array_st a h)\n  (ser_input a.a16_st (ser_u16 a.len16_st) `ser_append`\n   ser_copy a.a16_st)\n\nlet ser_u16_array' a input = ser_u16_array a input\n\nlet enc_u32_array_st (a: u32_array_st) (h:mem{live h a.a32_st}) : GTot bytes =\n  u32_to_be a.len32_st `append` as_seq h a.a32_st\n\n","line":204,"column":0}}
{"kind":"message","level":"error","contents":"Unexpected error; please file a bug report, ideally with a minimized version of the source program that triggered the error.\nFailure(\"(<input>(209,2-211,21)) CheckNoUvars: Unexpected unification variable remains: uu___unification_ 0\")\n"}
;;; Complete message received: (status: nil; message: ((kind . "message") (level . "error") (contents . "Unexpected error; please file a bug report, ideally with a minimized version of the source program that triggered the error.
;;; Failure(\"(<input>(209,2-211,21)) CheckNoUvars: Unexpected unification variable remains: uu___unification_ 0\")
;;; ")))
;;; Signal received: [exited abnormally with code 1
;;; ] [exit]