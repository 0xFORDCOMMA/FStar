(*
  Defines some of the data structures used by the servers participating in the OAuth protocol
*)
module OAuth.Datatypes

open FStar.All
open FStar.IO
open Web.Origin
open Web.URI
open Secret.SecString
open Browser.AuxiliaryDatatypes
open Browser.Datatypes
open AuxiliaryFunctions
open Browser.StringFunctions
open Browser.Model.Interface
open NetworkRequestInterface

(* The request and response used in the oauth protocol *)
(* Returns a new request if one is created, else an associated response *)
(* {requestResponseValid req resp} should be used *)
type retReqResp = 
| RetRequest : request -> retReqResp
| RetResponse : actResponse -> retReqResp

val isValidRetResp : request -> retReqResp -> GTot bool
let isValidRetResp r ret =
  match ret with 
  | RetRequest req -> notForbiddenHeaderfieldInReqHeader (Request?.rf req).reqhead 
  | RetResponse resp -> requestResponseValid r resp

(* The client_secret for RP generated by IP *)
let clientSecretRPIP = genSecret (SecretVal [rpori;ipori]) (* Generate this using randomString / genSecret *)
let clientIDRPIP = genSecret PublicVal

(* check if the secretVal (secLevel) is indexed by the origin - should not be a public value *)
val checkSecretOrigins : o:torigin -> l:secLevel -> Tot (b:bool)
let checkSecretOrigins o l =
  match l with 
      | PublicVal -> false  (* only allow origin-indexed secrets and no public values *)
      | SecretVal lo -> List.mem o lo

val secretOriginLemma  : o:torigin -> l:secLevel ->
				   Lemma (requires (checkSecretOrigins o l)) (ensures (restricts (l) (SecretVal [o]))) [SMTPat (checkSecretOrigins o l)]
let secretOriginLemma o l = match l with
      | PublicVal -> ()
      | SecretVal lo -> match [o] with | [] -> () | ol -> ()

(* returns true if the origin has a related secretvalue with that origin in its index *)
(* the secretvalue is indexed by both the origin from which the token is generated and the origin to which the token should be sent *)
val indexedOriginTL : list (torigin * secretVal) -> GTot bool
let rec indexedOriginTL tlist = 
  match tlist with 
  | [] -> true
  | (o,v)::tl -> checkSecretOrigins o (Secret?.s v) && indexedOriginTL tl

(* checks for the client_id and client_secret -- as above *)
val indexedOriginCD : list (torigin * secretVal * secretVal) -> GTot bool
let rec indexedOriginCD cdata = 
  match cdata with 
  | [] -> true
  | (o,i,v)::tl -> (Secret?.s i = PublicVal) && checkSecretOrigins o (Secret?.s v) && indexedOriginCD tl 

(* checks for the user and login session and the IdP origin using the session id (origin * session-id * state ) *)
val indexedOriginLS : list (torigin * secretVal * secretVal) -> GTot bool
let rec indexedOriginLS ls = 
  match ls with 
  | [] -> true
  | (o,i,v)::tl -> checkSecretOrigins o (Secret?.s i) && checkSecretOrigins o (Secret?.s v) && indexedOriginLS tl

(* checks for the authorization code list using the state (origin * state * authcode * redirect_uri) -- as above *)
val indexedOriginCL : list (torigin * secretVal * secretVal * uri) -> GTot bool
let rec indexedOriginCL clist = 
  match clist with 
  | [] -> true
  | (o,i,v,u)::tl -> checkSecretOrigins o (Secret?.s i) && checkSecretOrigins o (Secret?.s v) && indexedOriginCL tl

(* s:torigin is the rp/ip that owns the particular list *)
(* associates an origin with client_id and client_secret *)
type clientData' = list (torigin * secretVal * secretVal) (* Store the client id and secret for a given ip/rp *)
type clientData = c:(clientData'){indexedOriginCD c}

(* IP == associates an origin with state and authcode *)
type codeList' = list (rp:torigin * state:secretVal * code:secretVal * ruri:uri) (* Store the auth code for the rp given the state *)
type codeList = c:(codeList'){indexedOriginCL c}

(* RP == creates a new session id for the user corresponding to the state *)
type loginSession' = list (ip:torigin * sid:secretVal * state:secretVal) (* session id for state value sent to ip *)
type loginSession = l:(loginSession'){indexedOriginLS l}

(* associates an origin with accesstoken *)
type tokenList' = list (torigin * secretVal)
type tokenList = c:(tokenList'){indexedOriginTL c}

(* retrieve the client_id from the client_data table for the given origin-client *)
val getClientID : clientData -> torigin -> Tot (option secretVal)
let rec getClientID cd t = match cd with  
  | [] -> None
  | (o,v,_)::tl -> if o = t then Some v else getClientID tl t

(* retrieve the origin from the client_data table for the given client_id *)
val getCDOrigin : clientData -> secretVal -> Tot torigin
let rec getCDOrigin cd t = match cd with  
  | [] -> blank_origin
  | (o,v,_)::tl -> if v = t then o else getCDOrigin tl t

(* retrieve the client_secret from the client_data table for the given origin *)
val getCDSecret : clientData -> t:torigin -> Tot (option secretVal)
let rec getCDSecret cd t = match cd with  
  | [] -> None
  | (o,v,sv)::tl -> if o = t then Some sv else getCDSecret tl t

(* retrieve the IP origin for which the token (state) was generated *)
val getIPLogin : loginSession -> secretVal -> ML torigin
let rec getIPLogin ls s = match ls with
  | [] -> blank_origin
  | (o,_,t)::tl -> if s = t then o else getIPLogin tl s
		 
(* retrieve the authcode from the codelist for the given origin *)
val getCLRedURI : codeList -> torigin -> Tot (option uri)
let rec getCLRedURI cd t = match cd with  
  | [] -> None 
  | (o,v,sv,u)::tl -> if o = t then Some u else getCLRedURI tl t

(* retrieve the authcode from the codelist for the given origin *)
val getCLCode : codeList -> t:torigin -> Tot (option secretVal)
let rec getCLCode cd t = match cd with  
  | [] -> None 
  | (o,v,sv,u)::tl -> if o = t then Some sv else getCLCode tl t

(* retrieve the new codelist after using up the authcode for the given origin *)
val getNewCodeList : codeList -> t:torigin -> ac:secretVal -> ru:uri -> Tot (codeList)
let rec getNewCodeList cd t ac ru = match cd with  
  | [] -> []
  | (o,v,sv,u)::tl -> if o = t && sv = ac && u = ru then tl else (o,v,sv,u)::(getNewCodeList  tl t ac ru)

(* retrieve the access token from the list for the origin *)
val getTLToken : tokenList -> t:torigin -> Tot (option (s:secretVal))
let rec getTLToken l t = match l with  
  | [] -> None
  | (o,sv)::tl -> if o = t then Some sv else getTLToken tl t

val cdSecretLemma : l:clientData -> t:torigin -> Lemma (requires (True)) 
		    (ensures (match (getCDSecret l t) with | None -> true | Some sv -> checkSecretOrigins t (Secret?.s sv))) [SMTPat (getCDSecret l t)]
let rec cdSecretLemma l t = match l with 
  | [] -> ()
  | f::tl -> cdSecretLemma tl t

val clCodeLemma : l:codeList -> t:torigin -> Lemma (requires (True)) 
		  (ensures (match (getCLCode l t) with | None -> true | Some sv -> checkSecretOrigins t (Secret?.s sv))) [SMTPat (getCLCode l t)]
let rec clCodeLemma l t = match l with 
  | [] -> ()
  | f::tl -> clCodeLemma tl t

val tlTokenLemma : l:tokenList -> t:torigin -> Lemma (requires (True)) 
		   (ensures (match (getTLToken l t) with | None -> true | Some sv -> checkSecretOrigins t (Secret?.s sv))) [SMTPat (getTLToken l t)]
let rec tlTokenLemma l t = match l with 
  | [] -> ()
  | f::tl -> tlTokenLemma tl t

(* RP == Login session table for rp *)
(* val refLS : loginSession -> ref (loginSession) *)
let refLS (ls:loginSession) = ST.alloc ls

(* IP == client data table for ip *)
(* val refCD : clientData -> ref (clientData) *)
let refCD (cd:clientData) = ST.alloc cd

(* IP == auth code list for different rps for ip *)
(* val refCL : codeList -> ref (codeList) *)
let refCL (cl:codeList) = ST.alloc cl

(* IP == access-token list for different rps for ip *)
(* val refTL : tokenList s -> ref (tokenList) *)
let refTL (tl:tokenList) = ST.alloc tl


(***)
open FStar.All
open FStar.Heap
(* RP and IP data tables *)
(* data related to different ips - already present through registration *)
val rpCD : ref (clientData) (* for rpori *)
let rpCD = refCD [(ipori, clientIDRPIP, clientSecretRPIP)]

val rpLS : ref (loginSession) (* for rpori *)
let rpLS = refLS [] 

(* This should be the same for the RP and the IP - pre-registered *)
val ipCD : ref (clientData) (* for ipori *)
let ipCD = refCD [(rpori, clientIDRPIP,  clientSecretRPIP)]

(* The access token to be sent to the RP *)
val ipTL : ref (tokenList) (* for ipori *)
let ipTL = refTL []

(* create a code list for the IP *)
val ipCL : ref (codeList) (* for ipori *)
let ipCL = refCL []

(* a user-pass list along with the session cookies for the IP *)
type uList (s:secLevel) = (list (secString s * secString s * list (secString s)))
let refUL (#s:secLevel) (tl:uList s) = ST.alloc tl

val userList : ref (uList (SecretVal [ipori]))
let userList = refUL ([((classify #PublicVal "usernameU" (SecretVal [ipori])), (classify #PublicVal "passwordP" (SecretVal [ipori])), [])])

val getRPClientID : torigin -> ML (option secretVal)
let getRPClientID t = getClientID (!rpCD) t  

(* get the client_id for the origin *)
val getIPClientID : torigin -> ML (option secretVal)
let getIPClientID t = getClientID (!ipCD) t  

(* get the RP's origin using the client_id *)
val getRPOrigin : secretVal -> ML torigin
let getRPOrigin s = getCDOrigin (!ipCD) s

val addCookieList : #s:secLevel -> list (secString s * secString s * (list (secString s))) -> secString s -> secString s -> secString s -> 
		    Tot (list (secString s * secString s * (list (secString s))))
let rec addCookieList #s ul u p c =
  match ul with
    | [] -> []
    | (su,sp,sc)::tl -> if (u = su) && (p = sp) then (su,sp,c::sc)::tl
		      else (su,sp,sc)::(addCookieList #s tl u p c)


(* set a CSP policy for the response to allow only scripts from the current source to load *)
let list_dir_value = [DV_Self]
let cspDirD = {dir_name=CSP_default_src;dir_value=list_dir_value}
let cspPol = [cspDirD]


