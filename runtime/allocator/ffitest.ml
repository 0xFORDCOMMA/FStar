open Camlstack;;

(* DEBUG *)

(* *)

(* makes a (heap-allocated) pretty-printed string of a list *)
let rec string_of_list l p =
  match l with
      [] -> "[]"
    | h::t -> 
      let s = string_of_list t p in 
      (p h)^"::"^s
;;

let doGC() =
  print_mask ();
  Gc.full_major()
  (* Gc.print_stat (Pervasives.stdout) *)
;;

(* DATATYPES *)

push_frame ();;

type dt =
    A
  | B of int
  | C of int * int (* note that this is allocated as a two-word block, not a pointer to one *)
  | D of int list
  | E of (int * int)
;;

(* Use Obj.magic to construct these *)

let mkdt_B (x:int) : dt =
  let x = mkref_noscan x in (* basically, a ref is a "one tuple" *)
  let r = Obj.repr x in
  Obj.set_tag r 0;
  Obj.magic x
;;

let mkdt_C (x:int) (y:int) : dt = 
  let p = mkpair x y in
  let r = Obj.repr p in
  Obj.set_tag r 1;
  Obj.magic p
;;

let mkdt_D (xs:int list) : dt = 
  let xs = mkref xs in (* xs is a heap list, so scannable *)
  let r = Obj.repr xs in
  Obj.set_tag r 2;
  Obj.magic xs
;;

let mkdt_E (y:int) (z:int) : dt = 
  let p = mkpair y z in
  let x = mkref_noscan p in (* extra level of indirection due to parens around pair in dt decl *)
  let r = Obj.repr x in
  Obj.set_tag r 3;
  Obj.magic x
;;

let dt_to_string x =
  match x with
      A -> "A"
    | B x -> "(B "^(string_of_int x)^")"
    | C (x,y) -> "(C "^(string_of_int x)^", "^(string_of_int y)^")"
    | D xs -> "(D "^(string_of_list xs string_of_int)^")"
    | E (x,y) -> "(E "^(string_of_int x)^", "^(string_of_int y)^")"

let b = mkdt_B 1;;
inspect b;;
Printf.printf "%s\n" (dt_to_string b);;

let b = mkdt_C 1 2;;
inspect b;;
Printf.printf "%s\n" (dt_to_string b);;

let b = mkdt_D [1;2;7;8];;
inspect b;;
Printf.printf "%s\n" (dt_to_string b);;

let b = mkdt_E 1 2;;
inspect b;;
Printf.printf "%s\n" (dt_to_string b);;

(* (\* The following would be generated by the compiler. They are all *)
(*    in ffitest.c. There's no constructor for A because it's not boxed. *\) *)
(* external mkdt_B : int -> dt = "stack_mkdt_B";; *)
(* external mkdt_C : int -> int -> dt = "stack_mkdt_C";; *)
(* external mkdt_D : int list -> dt = "stack_mkdt_D";; *)

(* let check x = if x then () else failwith "assertion failed";; *)

pop_frame ();;

(* BYTE ARRAYS *)

let make n c =
  let str = mkbytes n in
  for i = 0 to (n-1) do
    Bytes.set str i c
  done;
  str;;

push_frame ();;

let s = make 10 'a';;
let s2 = make 35 '<';;
Printf.printf "|%s| |%s|\n" (Bytes.unsafe_to_string s) (Bytes.unsafe_to_string s2);;

pop_frame ();;

(* ARRAYS *)

push_frame ();;

let arr = Camlstack.mkarray 10 [1;2];;
doGC();;
arr.(0) <- [];
arr.(1) <- [];
arr.(2) <- [];
try 
  (arr.(11) <- [])
with Invalid_argument(_) -> print_string "out of bounds access handled\n";;
try 
  ignore(Camlstack.mkarray 10 1.0)
with Invalid_argument(_) -> print_string "illegal array contents handled\n";;

let darr = Camlstack.mkarray_noscan 10 1.0;;
doGC();;
darr.(0) <- 2.0;;
darr.(1) <- 3.0;;
darr.(2) <- 4.0;;

Printf.printf "%f %f %f %f\n" darr.(0) darr.(1) darr.(2) darr.(9);;

doGC();;

pop_frame ();;

(* LISTS *)

push_frame ();;

(* allocates a list on the stack, where the list elements point to heap-allocated lists *)
let rec mklist n =
  if n = 0 then []
  else
    let l = mklist (n-1) in
    cons (n::[1;2;3]) l 

let ex = mklist 10;;

Printf.printf "List result = %s\n" (string_of_list ex (fun l -> "("^(string_of_list l string_of_int)^")"));;
doGC();;
Printf.printf "List result = %s\n" (string_of_list ex (fun l -> "("^(string_of_list l string_of_int)^")"));;

pop_frame ();;

(* REFERENCES *)

push_frame ();;

let rec mkrefs n =
  if n = 0 then []
  else
    let l = mkrefs (n-1) in
    (mkref [])::l 

let rec modrefs l =
  match l with
      [] -> ()
    | h::t -> h := [1;2]; modrefs t

let ex = mkrefs 10;;
let p = mkref_noscan 1;;
doGC();;
let ex = modrefs ex;;
doGC();;

pop_frame ();;

(* ERROR HANDLING *)

doGC();;

(*
let _ = 
  try 
    ignore(cons "hello" [])
  with Failure s -> 
    Printf.printf "Tried to allocate with no frames pushed\n"
;;
*)

(*
let _ = 
  try 
    ignore(pop_frame ())
  with Failure s -> 
    Printf.printf "Tried to pop a frame with no frames pushed\n"
;;
*)
